import { Md5 } from "ts-md5";
import {
  EllipticCurve,
  EllipticCurvePoint,
} from "@/backend_code/real_fields_groups/group/elliptic_curve";
import {
  ZModuloP,
  ZModuloPElement,
} from "@/backend_code/real_fields_groups/field/zmodulo";
import { GroupElement } from "@/backend_code/group_theory/group";

function isPrimeNaive(n: bigint) {
  for (let i = 2n; i * i <= n; i++) {
    if (n % i === 0n) return false;
  }
  return n > 1n;
}

function isPrimeMillerRabin(n: bigint) {
  // This function returns true if n is a "prime" number
  // using Miller-Rabin primality test
  // (https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
  // and false otherwise.
  // The function is deterministic for n < 10^18
  // and is probabilistic for n >= 10^18.
  const k = 50; // number of rounds
  let s = 0n;
  let d = n - 1n;
  while (d % 2n === 0n) {
    s++;
    d /= 2n;
  }
  for (let i = 0; i < k; i++) {
    let a = randomBigInt(n - 4n) + 2n;
    if (gcdBigInt(a, n) > 1n) return false;
    let x = quickPowBigInt(a, d, n);
    for (let r = 0n; r < s; r++) {
      let y = roundModulo(x * x, n);
      if (y === 1n && x !== 1n && x !== n - 1n) {
        return false;
      }
      x = y;
    }
    if (x !== 1n) return false;
  }
  return true;
}

export function isPrime(n: bigint) {
  if (n >= 10n ** 6n) return isPrimeNaive(n);
  else return isPrimeMillerRabin(n);
}

export function quickPowBigInt(a: bigint, b: bigint, p: bigint): bigint {
  if (b === 0n) {
    return 1n;
  } else {
    let c: bigint = quickPowBigInt(a, b / 2n, p);
    if (b % 2n === 0n) {
      return roundModulo(c * c, p);
    } else {
      return roundModulo(c * c * a, p);
    }
  }
}

function eulerCriterion(a: bigint, p: bigint): bigint {
  return quickPowBigInt(a, (p - 1n) / 2n, p);
}

export function squareRootModulo(n: bigint, p: bigint): bigint {
  // this function returns the square root of n modulo p
  // if it exists, otherwise it returns -1
  // this is an implementation of Tonelli-Shanks algorithm
  // (https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm)
  if (n === 0n) return 0n;
  if (p === 2n) {
    return n;
  } else if (p % 4n === 3n) {
    if (eulerCriterion(n, p) === 1n) {
      return quickPowBigInt(n, (p + 1n) / 4n, p);
    } else {
      return -1n;
    }
  } else if (p % 4n === 1n) {
    // Using the Shanks method
    let s = 0n;
    let q = p - 1n;
    while (q % 2n === 0n) {
      s++;
      q /= 2n;
    }
    let z = 2n;
    // find a quadratic non-residue
    while (quickPowBigInt(z, (p - 1n) / 2n, p) === 1n) {
      z++;
    }
    let m = s;
    let c = quickPowBigInt(z, q, p);
    let t = quickPowBigInt(n, q, p);
    let r = quickPowBigInt(n, (q + 1n) / 2n, p);
    while (true) {
      if (t === 0n) {
        return 0n;
      } else if (t === 1n) {
        return r;
      }
      let i = 0n;
      let zz = t;
      while (zz !== 1n) {
        zz = roundModulo(zz * zz, p);
        i++;
      }
      if (i === m) return -1n;
      let b = quickPowBigInt(c, roundModulo(2n ** (m - i - 1n), p - 1n), p);
      m = i;
      c = roundModulo(b * b, p);
      t = roundModulo(t * c, p);
      r = roundModulo(r * b, p);
    }
  } else return -1n;
}

function getECOrderNaive(p: bigint, a: bigint, b: bigint) {
  // this is an algorithm that would return the number of
  // elements in the elliptic curve group generated by
  // a finite field of size p on curve equation y^2 = x^3 + ax + b
  // this is a naive implementation
  let count = 1n;
  for (let x = 0n; x < p; x++) {
    let y2 = roundModulo(x * x * x + a * x + b, p);
    let y = squareRootModulo(y2, p);
    if (y !== -1n) {
      count++;
      if (y !== 0n) count++;
    }
  }
  return count;
}

export function getOrderOfEllipticCurveGroup(p: bigint, a: bigint, b: bigint) {
  if (p < 500) {
    return getECOrderNaive(p, a, b);
  } else {
    return getECOrderBabyStepGiantStep(p, a, b);
  }
}

export function squareRootBigInt(a: bigint): [bigint, bigint] {
  let low = 0n;
  let high = a;
  while (low < high) {
    let mid = (low + high) / 2n;
    if (mid * mid < a) {
      low = mid + 1n;
    } else {
      high = mid;
    }
  }
  if (low * low === a) {
    return [low, low];
  } else {
    return [low - 1n, low];
  }
}

function babyStepGiantStepSearch<T extends { toString(): string }>(
  l: bigint,
  r: bigint,
  P: GroupElement<T>
): bigint | undefined {
  const g = P.getGroup();
  const m = squareRootBigInt(r - l + 1n)[0];
  const babyStep = new Map<string, bigint[]>();
  let cur = g.id();
  for (let i = 0n; i < m; i++) {
    babyStep.set(cur.toString(), []);
    let babyList = babyStep.get(cur.toString()) ?? [];
    babyStep.set(cur.toString(), [...babyList, i]);
    cur = g.sub(cur, P);
  }
  let L = g.quickMultiply(P, l);
  let block = g.quickMultiply(P, m);
  cur = L;
  for (let i = 0n; i < m; i++) {
    let babyList = babyStep.get(cur.toString());
    let val = babyList?.find((j) => {
      let x = l + i * m + j;
      if (x >= l && x <= r) {
        return true;
      }
    });
    if (val) return l + i * m + val;
    cur = g.add(cur, block);
  }
  // No solution found
  return undefined;
}

function gcdBigInt(a: bigint, b: bigint): bigint {
  if (b === 0n) return a;
  return gcdBigInt(b, a % b);
}

function lcmBigInt(a: bigint, b: bigint): bigint {
  return (a * b) / gcdBigInt(a, b);
}

function getOrder<T extends { toString(): string }>(
  k: bigint,
  P: GroupElement<T>
) {
  // We know that the order is a divisor of k
  // We can use this to reduce the search space
  const g = P.getGroup();
  for (let i = 1n; i * i <= k; i++) {
    if (k % i === 0n) {
      if (g.quickMultiply(P, i).equals(g.id())) {
        return i;
      }
      if (g.quickMultiply(P, k / i).equals(g.id())) {
        return k / i;
      }
    }
  }
  return k;
}

export function getECOrderBabyStepGiantStep(p: bigint, a: bigint, b: bigint) {
  // This is an implementation of baby step - giant step algorithm
  // utilizing Hasse's theorem to reduce the range of the search space
  // (https://en.wikipedia.org/wiki/Hasse%27s_theorem_on_elliptic_curves)
  // (https://en.wikipedia.org/wiki/Baby-step_giant-step)
  // Hasse's theorem ensure search space of n
  // being from p - 2sqrt(p) + 1 to p + 2sqrt(p) + 1
  const bottom = p - squareRootBigInt(4n * p)[1] + 1n;
  const top = p + squareRootBigInt(4n * p)[0] + 1n;
  const range = top - bottom + 1n;
  const ZP = new ZModuloP(p);
  const Za = ZP.newElement(a);
  const Zb = ZP.newElement(b);

  // Setting up curve E
  const curve = new EllipticCurve(Za, Zb, ZP);
  const S = new Set<bigint>();
  while (S.size < 2) {
    const [Px, Py] = getRandomPoint(p, a, b);
    const P = new EllipticCurvePoint(false, curve, Px, Py);
    const n_1 = babyStepGiantStepSearch(bottom, top, P); // this guarantees to find a solution
    const n_2 = babyStepGiantStepSearch((n_1 as bigint) + 1n, top, P);
    const n_3 = babyStepGiantStepSearch(bottom, (n_1 as bigint) - 1n, P);
    if ((n_2 ?? n_3) === undefined) {
      return n_1 as bigint; // only one solution found
    } else {
      const o = gcdBigInt(n_1 as bigint, (n_2 ?? n_3) as bigint);
      S.add(getOrder(o, P));
    }
  }
  const M = [...S].reduce((acc, cur) => lcmBigInt(acc, cur));
  if (M > range) {
    // find l such that lM is in the range
    const l = top / M;
    return l * M;
  }

  // Setting up curve E' : y^2 = x^3 + ag^2x + bg^3
  // First, finding g such that g is not a square root modulo p
  let g = 0n;
  while (g === 0n && squareRootModulo(g, p) === -1n) {
    g = randomBigInt(p);
  }
  const Zag2 = ZP.newElement(a * g * g);
  const Zbg3 = ZP.newElement(b * g * g * g);
  const curve2 = new EllipticCurve(Zag2, Zbg3, ZP);
  const S2 = new Set<bigint>();
  while (S2.size < 2) {
    const [Px, Py] = getRandomPoint(p, a * g * g, b * g * g * g);
    const P = new EllipticCurvePoint(false, curve2, Px, Py);
    const n_1 = babyStepGiantStepSearch(bottom, top, P); // this guarantees to find a solution
    const n_2 = babyStepGiantStepSearch((n_1 as bigint) + 1n, top, P);
    const n_3 = babyStepGiantStepSearch(bottom, (n_1 as bigint) - 1n, P);
    if ((n_2 ?? n_3) === undefined) {
      return 2n * (p + 1n) - (n_1 as bigint); // only one solution found
    } else {
      const o = gcdBigInt(n_1 as bigint, (n_2 ?? n_3) as bigint);
      S2.add(getOrder(o, P));
    }
  }
  const M2 = [...S2].reduce((acc, cur) => lcmBigInt(acc, cur));
  if (M2 > range) {
    // find l such that lM is in the range
    const l = top / M2;
    return 2n * (p + 1n) - l * M2;
  }
  // No solution found???
  return -1n;
}

function roundModulo(a: bigint, p: bigint) {
  // this function returns a modulo p in the range [0, p)
  return ((a % p) + p) % p;
}

function getRandomPoint(p: bigint, a: bigint, b: bigint): [bigint, bigint] {
  // this function returns a random point in the elliptic curve group
  // generated by a finite field of size p on curve equation y^2 = x^3 + ax + b
  // this is a naive implementation
  // Random until found
  while (true) {
    let x = randomBigInt(p);
    let y2 = roundModulo(x * x * x + a * x + b, p);
    let y = squareRootModulo(y2, p);
    if (y !== -1n) {
      return [x, y];
    }
  }
}

export function getGeneratorOfEllipticCurveGroup(
  p: bigint,
  a: bigint,
  b: bigint
): [bigint, bigint] {
  return getRandomPoint(p, a, b);
}

export function randomBigInt(maxExclusive: bigint): bigint {
  const bitLength = maxExclusive.toString(2).length;
  const byteLength = Math.ceil(bitLength / 8);

  let randomNumber = BigInt(0);
  for (let i = 0; i < byteLength; i++) {
    randomNumber <<= BigInt(8);
    randomNumber |= BigInt(Math.floor(Math.random() * 256));
  }

  // Ensure that the result is within the range [0, maxExclusive)
  randomNumber = randomNumber % maxExclusive;

  return randomNumber;
}

export function hashToBigInt(
  G: EllipticCurvePoint<ZModuloPElement, bigint>,
  V: EllipticCurvePoint<ZModuloPElement, bigint>,
  R: EllipticCurvePoint<ZModuloPElement, bigint>,
  pModulo: bigint
): bigint {
  const hashArray: Int32Array = new Md5()
    .appendStr(G.toString())
    .appendStr(V.toString())
    .appendStr(R.toString())
    .end(true) as Int32Array;
  const byteArray = new Uint8Array(hashArray.buffer);
  // Convert Uint8Array to BigInt
  const bigintVal = BigInt(
    "0x" + [...byteArray].map((b) => b.toString(16).padStart(2, "0")).join("")
  );
  // Make sure the value is less than pModulo
  return bigintVal % pModulo;
}

export function hashString2BigInt(message: string, pModulo: bigint): bigint {
  const hashArray: Int32Array = new Md5()
    .appendStr(message)
    .end(true) as Int32Array;
  const byteArray = new Uint8Array(hashArray.buffer);
  // Convert Uint8Array to BigInt
  const bigintVal = BigInt(
    "0x" + [...byteArray].map((b) => b.toString(16).padStart(2, "0")).join("")
  );
  // Make sure the value is less than pModulo
  return bigintVal % pModulo;
}

export function convertECP2BIP(
  point: EllipticCurvePoint<ZModuloPElement, bigint>
): BigIntPoint {
  if (point.equals(point.getGroup().id())) {
    return "identity";
  } else {
    return {
      x: point.getValue().x as bigint,
      y: point.getValue().y as bigint,
    };
  }
}

function bigintPointToStringPoint(point: BigIntPoint): StrPoint {
  if (point === "identity") {
    return "identity";
  }

  return {
    x: point.x.toString(),
    y: point.y.toString(),
  };
}

export function convertVPResponseToString(
  response: VP_Response
): VP_str_Response {
  const { p, a, b, G, A, R, c, s, sG, R_plus_cA, n } = response;
  return {
    p: p.toString(),
    a: a.toString(),
    b: b.toString(),
    G: bigintPointToStringPoint(G),
    A: bigintPointToStringPoint(A),
    R: bigintPointToStringPoint(R),
    c: c.toString(),
    s: s.toString(),
    sG: bigintPointToStringPoint(sG),
    R_plus_cA: bigintPointToStringPoint(R_plus_cA),
    n: n.toString(),
  };
}

export function convertDSResponseToString(
  response: DS_Response
): DS_str_Response {
  const {
    p,
    a,
    b,
    G,
    A,
    M,
    c,
    signature,
    sG,
    R_plus_cA,
    sM,
    rM_plus_c_p_aM,
    n,
  } = response;
  return {
    p: p.toString(),
    a: a.toString(),
    b: b.toString(),
    G: bigintPointToStringPoint(G),
    A: bigintPointToStringPoint(A),
    M: bigintPointToStringPoint(M),
    c: c.toString(),
    signature: {
      s: signature.s.toString(),
      p_aM: bigintPointToStringPoint(signature.p_aM),
      rM: bigintPointToStringPoint(signature.rM),
      R: bigintPointToStringPoint(signature.R),
    },
    sG: bigintPointToStringPoint(sG),
    R_plus_cA: bigintPointToStringPoint(R_plus_cA),
    sM: bigintPointToStringPoint(sM),
    rM_plus_c_p_aM: bigintPointToStringPoint(rM_plus_c_p_aM),
    n: n.toString(),
  };
}

function checkIsNegative(value: bigint, varName: string) {
  if (value < 0n) {
    throw new Error(`Negative input for ${varName} is invalid!`);
  }
}

function checkIsSingular(p: bigint, a: bigint, b: bigint) {
  if ((4n * a ** 3n + 27n * b ** 2n) % p === 0n) {
    throw new Error(`Singular curve is invalid!`);
  }
}

function checkIsPrime(p: bigint) {
  if (!isPrime(p)) {
    throw new Error(`p must be prime!`);
  }
}

function checkSmaller(a: bigint, p: bigint, varName: string) {
  if (a >= p) {
    throw new Error(`${varName} must be smaller than p!`);
  }
}

function checkTooBigNumber(number: bigint, varName: string) {
  if (number.toString().length > 20) {
    throw new Error(
      `${varName} is too big! Please enter number of less than 15 digits!`
    );
  }
}

export function checkValidInput(p: bigint, a: bigint, b: bigint) {
  checkIsPrime(p);
  checkIsNegative(p, "p");
  checkIsNegative(a, "a");
  checkIsNegative(b, "b");
  checkIsSingular(p, a, b);
  checkSmaller(a, p, "a");
  checkSmaller(b, p, "b");
  checkTooBigNumber(p, "p");
  checkTooBigNumber(a, "a");
  checkTooBigNumber(b, "b");
}
