import { Md5 } from "ts-md5";
import { EllipticCurvePoint } from "@/backend_code/real_fields_groups/group/elliptic_curve";
import { ZModuloPElement } from "@/backend_code/real_fields_groups/field/zmodulo";

export function isPrime(n: bigint) {
  for (let i = 2n; i * i <= n; i++) {
    if (n % i === 0n) return false;
  }
  return n > 1n;
}

export function quickPowBigInt(a: bigint, b: bigint, p: bigint): bigint {
  if (b === 0n) {
    return 1n;
  } else {
    let c: bigint = quickPowBigInt(a, b / 2n, p);
    if (b % 2n === 0n) {
      return roundModulo(c * c, p);
    } else {
      return roundModulo(c * c * a, p);
    }
  }
}

function eulerCriterion(a: bigint, p: bigint): bigint {
  return quickPowBigInt(a, (p - 1n) / 2n, p);
}

export function squareRootModulo(n: bigint, p: bigint): bigint {
  // this function returns the square root of n modulo p
  // if it exists, otherwise it returns -1
  // this is an implementation of Tonelli-Shanks algorithm
  // (https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm)
  if (n === 0n) return 0n;
  if (p === 2n) {
    return n;
  } else if (p % 4n === 3n) {
    if (eulerCriterion(n, p) === 1n) {
      return quickPowBigInt(n, (p + 1n) / 4n, p);
    } else {
      return -1n;
    }
  } else if (p % 4n === 1n) {
    // Using the Shanks method
    let s = 0n;
    let q = p - 1n;
    while (q % 2n === 0n) {
      s++;
      q /= 2n;
    }
    let z = 2n;
    // find a quadratic non-residue
    while (quickPowBigInt(z, (p - 1n) / 2n, p) === 1n) {
      z++;
    }
    let m = s;
    let c = quickPowBigInt(z, q, p);
    let t = quickPowBigInt(n, q, p);
    let r = quickPowBigInt(n, (q + 1n) / 2n, p);
    while (true) {
      if (t === 0n) {
        return 0n;
      } else if (t === 1n) {
        return r;
      }
      let i = 0n;
      let zz = t;
      while (zz !== 1n) {
        zz = roundModulo(zz * zz, p);
        i++;
      }
      if (i === m) return -1n;
      let b = quickPowBigInt(c, roundModulo(2n ** (m - i - 1n), p - 1n), p);
      m = i;
      c = roundModulo(b * b, p);
      t = roundModulo(t * c, p);
      r = roundModulo(r * b, p);
    }
  } else return -1n;
}

export function getOrderOfEllipticCurveGroup(p: bigint, a: bigint, b: bigint) {
  // this is an algorithm that would return the number of
  // elements in the elliptic curve group generated by
  // a finite field of size p on curve equation y^2 = x^3 + ax + b
  // this is a naive implementation
  let count = 1n;
  for (let x = 0n; x < p; x++) {
    let y2 = roundModulo(x * x * x + a * x + b, p);
    let y = squareRootModulo(y2, p);
    if (y !== -1n) {
      count++;
      if (y !== 0n) count++;
    }
  }
  return count;
}

function roundModulo(a: bigint, p: bigint) {
  // this function returns a modulo p in the range [0, p)
  return ((a % p) + p) % p;
}

export function getGeneratorOfEllipticCurveGroup(
  p: bigint,
  a: bigint,
  b: bigint
): [bigint, bigint] {
  // this function returns a generator of the elliptic curve group
  // generated by a finite field of size p on curve equation y^2 = x^3 + ax + b
  // this is a naive implementation
  for (let x = 0n; x < p; x++) {
    let y2 = roundModulo(x * x * x + a * x + b, p);
    let y = squareRootModulo(y2, p);
    if (y !== -1n) {
      return [x, y];
    }
  }
  throw new Error("No generator found");
}

export function randomBigInt(maxExclusive: bigint): bigint {
  const bitLength = maxExclusive.toString(2).length;
  const byteLength = Math.ceil(bitLength / 8);

  let randomNumber = BigInt(0);
  for (let i = 0; i < byteLength; i++) {
    randomNumber <<= BigInt(8);
    randomNumber |= BigInt(Math.floor(Math.random() * 256));
  }

  // Ensure that the result is within the range [0, maxExclusive)
  randomNumber = randomNumber % maxExclusive;

  return randomNumber;
}

export function hashToBigInt(
  G: EllipticCurvePoint<ZModuloPElement, bigint>,
  V: EllipticCurvePoint<ZModuloPElement, bigint>,
  R: EllipticCurvePoint<ZModuloPElement, bigint>,
  pModulo: bigint
): bigint {
  const hashArray: Int32Array = new Md5()
    .appendStr(G.toString())
    .appendStr(V.toString())
    .appendStr(R.toString())
    .end(true) as Int32Array;
  const byteArray = new Uint8Array(hashArray.buffer);
  // Convert Uint8Array to BigInt
  const bigintVal = BigInt(
    "0x" + [...byteArray].map((b) => b.toString(16).padStart(2, "0")).join("")
  );
  // Make sure the value is less than pModulo
  return bigintVal % pModulo;
}

export function hashString2BigInt(message: string, pModulo: bigint): bigint {
  const hashArray: Int32Array = new Md5()
    .appendStr(message)
    .end(true) as Int32Array;
  const byteArray = new Uint8Array(hashArray.buffer);
  // Convert Uint8Array to BigInt
  const bigintVal = BigInt(
    "0x" + [...byteArray].map((b) => b.toString(16).padStart(2, "0")).join("")
  );
  // Make sure the value is less than pModulo
  return bigintVal % pModulo;
}

export function convertECP2BIP(
  point: EllipticCurvePoint<ZModuloPElement, bigint>
): BigIntPoint {
  if (point.equals(point.getGroup().id())) {
    return "identity";
  } else {
    return {
      x: point.getValue().x as bigint,
      y: point.getValue().y as bigint,
    };
  }
}

function bigintPointToStringPoint(point: BigIntPoint): StrPoint {
  if (point === "identity") {
    return "identity";
  }

  return {
    x: point.x.toString(),
    y: point.y.toString(),
  };
}

export function convertVPResponseToString(
  response: VP_Response
): VP_str_Response {
  const { p, a, b, G, A, R, c, s, sG, R_plus_cA, n } = response;
  return {
    p: p.toString(),
    a: a.toString(),
    b: b.toString(),
    G: bigintPointToStringPoint(G),
    A: bigintPointToStringPoint(A),
    R: bigintPointToStringPoint(R),
    c: c.toString(),
    s: s.toString(),
    sG: bigintPointToStringPoint(sG),
    R_plus_cA: bigintPointToStringPoint(R_plus_cA),
    n: n.toString(),
  };
}

export function convertDSResponseToString(
  response: DS_Response
): DS_str_Response {
  const {
    p,
    a,
    b,
    G,
    A,
    M,
    c,
    signature,
    sG,
    R_plus_cA,
    sM,
    rM_plus_c_p_aM,
    n,
  } = response;
  return {
    p: p.toString(),
    a: a.toString(),
    b: b.toString(),
    G: bigintPointToStringPoint(G),
    A: bigintPointToStringPoint(A),
    M: bigintPointToStringPoint(M),
    c: c.toString(),
    signature: {
      s: signature.s.toString(),
      p_aM: bigintPointToStringPoint(signature.p_aM),
      rM: bigintPointToStringPoint(signature.rM),
      R: bigintPointToStringPoint(signature.R),
    },
    sG: bigintPointToStringPoint(sG),
    R_plus_cA: bigintPointToStringPoint(R_plus_cA),
    sM: bigintPointToStringPoint(sM),
    rM_plus_c_p_aM: bigintPointToStringPoint(rM_plus_c_p_aM),
    n: n.toString(),
  };
}
