import { Md5 } from "ts-md5";
import { EllipticCurvePoint } from "@/backend_code/real_fields_groups/group/elliptic_curve";
import { ZModuloPElement } from "@/backend_code/real_fields_groups/field/zmodulo";

export function isPrime(n: bigint) {
  for (let i = 2n; i * i <= n; i++) {
    if (n % i === 0n) return false;
  }
  return n > 1n;
}

export function quickPowBigInt(a: bigint, b: bigint): bigint {
  if (b === 0n) {
    return 1n;
  } else {
    let c: bigint = quickPowBigInt(a, b / 2n);
    if (b % 2n === 0n) {
      return c * c;
    } else {
      return c * c * a;
    }
  }
}

export function squareRootModulo(n: bigint, p: bigint): bigint {
  // this function returns the square root of n modulo p
  // if it exists, otherwise it returns -1
  // this is an implementation of Tonelli-Shanks algorithm
  // (https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm)
  if (p % 4n === 3n) {
    return quickPowBigInt(n, (p + 1n) / 4n) % p;
  } else if (p % 8n === 5n) {
    let x = quickPowBigInt(n, (p + 3n) / 8n) % p;
    let b = quickPowBigInt(x, 2n) % p;
    if (b === n % p) {
      return x;
    } else {
      return (x * quickPowBigInt(2n, (p - 1n) / 4n)) % p;
    }
  } else {
    // find a quadratic non-residue
    let q = 2n;
    while (true) {
      if (isPrime(q) && squareRootModulo(q, p) === -1n) {
        break;
      }
      q++;
    }
    let s = 0n;
    let t = p - 1n;
    while (t % 2n === 0n) {
      s++;
      t /= 2n;
    }
    let inv_n = quickPowBigInt(n, p - 2n) % p;
    let inv_q = quickPowBigInt(q, p - 2n) % p;
    let z = quickPowBigInt(q, t) % p;
    let r = quickPowBigInt(n, (t + 1n) / 2n) % p;
    let m = s;
    while (true) {
      if (m === 0n) {
        return r;
      }
      let i = 0;
      let zz = z;
      while (i < m - 1n) {
        zz = quickPowBigInt(zz, 2n) % p;
        i++;
      }
      if (zz === 1n) {
        return r;
      }
      let b = quickPowBigInt(zz, quickPowBigInt(2n, s - m - 1n)) % p;
      r = (r * b) % p;
      z = (b * b) % p;
      m = s;
    }
  }
}

export function getOrderOfEllipticCurveGroup(p: bigint, a: bigint, b: bigint) {
  // this is an algorithm that would return the number of
  // elements in the elliptic curve group generated by
  // a finite field of size p on curve equation y^2 = x^3 + ax + b
  // this is a naive implementation
  let count = 1n;
  for (let x = 0n; x < p; x++) {
    let y2 = quickPowBigInt(x, 3n) + a * x + b;
    let y = squareRootModulo(y2, p);
    if (y !== -1n) {
      count++;
    }
  }
  return count;
}

export function getGeneratorOfEllipticCurveGroup(
  p: bigint,
  a: bigint,
  b: bigint
): [bigint, bigint] {
  // this function returns a generator of the elliptic curve group
  // generated by a finite field of size p on curve equation y^2 = x^3 + ax + b
  // this is a naive implementation
  for (let x = 0n; x < p; x++) {
    let y2 = quickPowBigInt(x, 3n) + a * x + b;
    let y = squareRootModulo(y2, p);
    if (y !== -1n) {
      return [x, y];
    }
  }
  throw new Error("No generator found");
}

export function randomBigInt(maxExclusive: bigint): bigint {
  const randomBytes = new Uint8Array(maxExclusive.toString(16).length / 2);
  crypto.getRandomValues(randomBytes);
  let randomNumber = BigInt(
    "0x" + [...randomBytes].map((b) => b.toString(16).padStart(2, "0")).join("")
  );

  while (randomNumber >= maxExclusive) {
    randomNumber = randomBigInt(maxExclusive);
  }

  return randomNumber;
}

export function hashToBigInt(
  G: EllipticCurvePoint<ZModuloPElement, bigint>,
  V: EllipticCurvePoint<ZModuloPElement, bigint>,
  R: EllipticCurvePoint<ZModuloPElement, bigint>,
  pModulo: bigint
): bigint {
  const hashArray: Int32Array = new Md5()
    .appendStr(G.toString())
    .appendStr(V.toString())
    .appendStr(R.toString())
    .end(true) as Int32Array;
  const byteArray = new Uint8Array(hashArray.buffer);
  // Convert Uint8Array to BigInt
  const bigintVal = BigInt(
    "0x" + [...byteArray].map((b) => b.toString(16).padStart(2, "0")).join("")
  );
  // Make sure the value is less than pModulo
  return bigintVal % pModulo;
}

export function hashString2BigInt(message: string, pModulo: bigint): bigint {
  const hashArray: Int32Array = new Md5()
    .appendStr(message)
    .end(true) as Int32Array;
  const byteArray = new Uint8Array(hashArray.buffer);
  // Convert Uint8Array to BigInt
  const bigintVal = BigInt(
    "0x" + [...byteArray].map((b) => b.toString(16).padStart(2, "0")).join("")
  );
  // Make sure the value is less than pModulo
  return bigintVal % pModulo;
}
